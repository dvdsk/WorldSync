use std::sync::Arc;

use protocol::*;
use tarpc::{client, context, tokio_serde::formats::Json};
use tokio::net::TcpStream;
use tokio_rustls::{rustls, TlsConnector, client::TlsStream};

async fn connect_tls(domain: &str) -> TlsStream<TcpStream> {
    let mut roots = rustls::RootCertStore::empty();
    for cert in rustls_native_certs::load_native_certs().expect("could not load os certificates") {
        roots.add(&rustls::Certificate(cert.0)).unwrap();
    }
    let config = rustls::ClientConfig::builder()
        .with_safe_defaults()
        .with_root_certificates(roots)
        .with_no_client_auth();
    let connector = TlsConnector::from(Arc::new(config));
    let domain = rustls::ServerName::try_from("davidsk.dev").unwrap();

    let stream = TcpStream::connect("127.0.0.1:25566").await.unwrap();
    connector.connect(domain, stream).await.unwrap()
}

// /// used for testing only
// async fn connect_localhost() -> TcpStream

#[tokio::main]
async fn main() {
    let stream = connect_tls("davidsk.dev").await;
    let transport = tarpc::serde_transport::Transport::from((stream, Json::default()));
    // let transport = tarpc::serde_transport::tcp::connect("127.0.0.1", Json::default);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let client = WorldClient::new(client::Config::default(), transport).spawn();

    let hello = async move {
        // Send the request twice, just to be safe! ;)
        tokio::select! {
            hello1 = client.hello(context::current(), format!("hello 1")) => { hello1 }
            hello2 = client.hello(context::current(), format!("hello 2")) => { hello2 }
        }
    }
    .await;
}
