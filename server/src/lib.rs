use futures::future;
use futures::StreamExt;
use protocol::Event;
use std::collections::HashMap;
use std::net::{IpAddr, Ipv4Addr};
use std::sync::Arc;
use std::sync::RwLock;
use tokio::sync::broadcast;
use tokio::sync::Mutex;
use tracing::info;

use protocol::{tarpc, Service, UserId};
use tarpc::server::{incoming::Incoming, Channel};
use tarpc::tokio_serde::formats::Json;
use uuid::Uuid;

pub mod admin_ui;
pub mod db;
mod world;
use db::user::UserDb;
pub use world::World;
mod rpc;
use rpc::ConnState;

type SessionId = Uuid;
pub struct Session {
    user_id: UserId,
    backlog: Arc<Mutex<broadcast::Receiver<Event>>>,
}

#[derive(Clone, Default)]
pub struct Sessions {
    by_id: Arc<RwLock<HashMap<SessionId, Session>>>,
}
//let (event_tx, _) = broadcast::channel(100);
impl Sessions {
    fn add(&mut self, user_id: UserId, backlog: broadcast::Receiver<Event>) -> SessionId {
        let uuid = Uuid::new_v4();
        let mut sessions = self.by_id.write().unwrap();
        let session = Session {
            user_id,
            backlog: Arc::new(Mutex::new(backlog)),
        };
        sessions.insert(uuid, session);
        uuid
    }
    pub fn get_user_id(&self, id: SessionId) -> Option<UserId> {
        self.by_id.read().unwrap().get(&id).map(|s| s.user_id)
    }
    pub fn clear_user(&self, id: UserId) {
        self.by_id.write().unwrap().retain(|_, v| v.user_id != id)
    }
}

pub fn version() -> &'static str {
    env!("CARGO_PKG_VERSION")
}

#[cfg(not(feature = "deployed"))]
pub async fn send_test_hb(event_sender: broadcast::Sender<Event>) {
    use std::time::Duration;
    use tokio::time;

    let mut number = 0;
    loop {
        event_sender.send(Event::TestHB(number)).unwrap();
        time::sleep(Duration::from_secs(5)).await;
        number += 1;
    }
}

pub fn events_channel() -> Arc<broadcast::Sender<Event>> {
    Arc::new(broadcast::channel(50).0)
}

pub async fn host(
    sessions: Sessions,
    userdb: UserDb,
    world: World,
    port: u16,
    events: Arc<broadcast::Sender<Event>>,
) {
    let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), port);

    info!("starting listener on port {}", port);
    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
        .await
        .unwrap();
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(tarpc::server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let peer_addr = channel.transport().peer_addr().unwrap();
            let server = ConnState {
                peer_addr,
                events: events.clone(),
                sessions: sessions.clone(),
                userdb: userdb.clone(),
                world: world.clone(),
            };
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
}
