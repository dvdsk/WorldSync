use futures::future;
use futures::StreamExt;
use std::collections::HashMap;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::sync::Arc;
use std::sync::RwLock;
use std::time::Instant;

use protocol::{tarpc, Credentials, World};
use tarpc::context;
use tarpc::server::{incoming::Incoming, Channel};
use tarpc::tokio_serde::formats::Json;

pub mod db;
use db::user::{User, UserDb};

pub struct Session {
    user: User,
    last_hb: Instant,
}

use uuid::Uuid;
#[derive(Clone)]
pub struct Sessions(Arc<RwLock<HashMap<Uuid, Session>>>);

impl Sessions {
    pub fn new() -> Self {
        Self(Arc::new(RwLock::new(HashMap::new())))
    }
    fn add(&mut self, user: User) -> Uuid {
        let uuid = Uuid::new_v4();
        let mut sessions = self.0.write().unwrap();
        let session = Session {
            user,
            last_hb: Instant::now(),
        };
        sessions.insert(uuid, session);
        uuid
    }
}

#[derive(Clone)]
pub struct ConnState {
    pub peer_addr: SocketAddr,
    pub sessions: Sessions,
    pub userdb: UserDb,
}

pub fn version() -> &'static str{ 
    env!("CARGO_PKG_VERSION")
}

#[tarpc::server]
impl World for ConnState {
    async fn version(self, _: context::Context) -> protocol::Version {
        protocol::Version { 
            protocol: protocol::version().to_owned(), 
            server: self::version().to_owned(),
        }
    }
    async fn log_in(mut self, _: context::Context, credentials: Credentials) -> Result<Uuid, ()> {
        if let Ok(user) = self.userdb.validate_credentials(credentials).await {
            let uuid = self.sessions.add(user);
            Ok(uuid)
        } else {
            Err(())
        }
    }
}

pub async fn host(sessions: Sessions, userdb: UserDb, port: u16) {
    let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), port);

    // JSON transport is provided by the json_transport tarpc module. It makes it easy
    // to start up a serde-powered json serialization strategy over TCP.
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default)
        .await
        .unwrap();
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(tarpc::server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let peer_addr = channel.transport().peer_addr().unwrap();
            let server = ConnState {
                peer_addr,
                sessions: sessions.clone(),
                userdb: userdb.clone(),
            };
            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
}
